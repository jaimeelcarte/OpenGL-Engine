#version 430 core
#extension GL_ARB_compute_shader : enable
#extension FL_ARB_shader_storage_buffer_object : enable

layout(std140, binding = 4) buffer Pos
{
	vec4 Positions[];	// array of structures
};

layout(std140, binding = 5) buffer Vel
{
	vec4 Velocities[];	// array of structures
};

layout(std140, binding = 6) buffer Col
{
	vec4 Colors[];	// array of structures
};

layout(std140, binding = 7) buffer PrevPos
{
	vec4 PrevPositions[];	// array of structures
};

layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

//	variables existentes:
//	in uvec3 gl_NumWorkGroups   ->   Same numbers as in the glDispatchCompute call
//	const uvec3 gl_WorkGroupSize   ->   Same numbers as in the layout local_size_*
//	in uvec3 gl_WorkGroupID   ->   Which workgroup this thread is in
//	in uvec3 gl_LocalInvocationID   ->   Where this thread is in the current workgroup
//	in uvec3 gl_GlobalInvocationID   ->   Where this thread is in all the work items
//	in uint gl_LocalInvocationIndex   ->   ID representation of the gl_LocalInvocationID
//                                         (used for indexing into a shared array)

uniform int usingVerlet;

const vec3 G = vec3(0.0, -9.8, 0.0);
vec3 A = vec3(0.0);
const float DT = 0.001;

const vec4 SPHERE = vec4(0.0, 0.0, 0.0, 5.0);

vec3 Bounce (vec3 vin, vec3 n)
{
	return reflect(vin, n);
}

vec3 BounceSphere (vec3 p, vec3 v, vec4 s)
{
	vec3 n = normalize(p - s.xyz);
	return Bounce(v, n);
}

bool IsInsideSphere(vec3 p, vec4 s)
{
	float r = length(p - s.xyz);
	return (r < s.w);
}

void main()
{
	uint gid = gl_GlobalInvocationID.x; // the .y and .z are both 1 in this case
	vec3 p = Positions[gid].xyz;
	vec3 prevP = PrevPositions[gid].xyz;
	vec3 v = Velocities[gid].xyz;
	
//	vec3 f = normalize(A-p)*9.8 + G;
	vec3 f = G;

	vec3 pp;
	vec3 vp = v;
	if (usingVerlet == 1)
	{
		
		if (PrevPositions[gid].w == 0)
		{
			pp = p + v*DT + 0.5*DT*DT*f;
			PrevPositions[gid].w = 1;
			if (pp.y <= -6)
			{
				vp = Bounce(v, vec3(0.0, 1.0, 0.0));
				pp = p + vp*DT + 0.5*DT*DT*f;
			}
		}
		else
		{
			pp = (2 * p) - prevP + 0.5*DT*DT*f;
			if (pp.y <= -6)
			{
				vp = Bounce(v, vec3(0.0, 1.0, 0.0));
				pp = p + vp*DT + 0.5*DT*DT*f;
			}
		}
		PrevPositions[gid] = Positions[gid];
		Positions[gid].xyz = pp;
		Velocities[gid].xyz = vp;
	}
	else
	{
		pp = p + v*DT + 0.5*DT*DT*G;
		vp = v + G*DT;
		/*
		if (IsInsideSphere(pp, SPHERE))
		{
			vp = BounceSphere(p, v, SPHERE);
			pp = p + vp*DT + 0.5*DT*DT*G;
		}
		*/
		if (pp.y <= -6)
		{
			vp = Bounce(v, vec3(0.0, 1.0, 0.0));
			pp = p + vp*DT + 0.5*DT*DT*G;
		}
	
		
		Positions[gid].xyz = pp;
		Velocities[gid].xyz = vp;
	}
	

}
